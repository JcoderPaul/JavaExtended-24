Метод collect принимает объект типа Collector, с помощью которого можно производить предварительные
действия над элементами стрима (потока). Это может быть операция фильтрации, группировки и так далее.
Collector - это интерфейс со следующими функциями:

 - Supplier supplier() - supplier возвращает функцию, которая создает внутренний контейнер для работы
                         со стримом значений. Вся работа со значениями будет проходить через этот контейнер.
                         Нужен для создания новых результирующих контейнеров. Ведь «прилетающие» в потоке
                         (в стриме) данные необходимо куда-то складывать;

 - BiConsumer accumulator() - accumulator возвращает функцию, которая получает очередной элемент (потока)
                              стрима и добавляет его во внутренний контейнер. Занимается сложением, или
                              аккумуляцией данных. Аккумулятор складирует приходящие данные во временные
                              контейнеры;

 - BinaryOperator combiner() - данная функция возвращает бинарный оператор, который получает два контейнера
                               и производит их объединение. Combiner объединяет полученные временные
                               контейнеры в более крупный, что по итогу приводит к получению агрегированных
                               данных;

 - Function finisher() - данная функция возвращает функцию, которая получает из внутреннего контейнера
                         значение и его возвращает. Опционально, но не обязательно, может присутствовать
                         Finisher, который проведет post-обработку полученного глобального контейнера и
                         вернет уже результат в качестве итога работы коллектора.

 - Set characteristics() - данная функция возвращает множества характеристик.
 Что из себя представляет данный Collector?
    Characteristics - это перечисление. Возможные значения следующие:
        - CONCURRENT - при выставлении данного значения в качестве характеристики коллектора означает,
                       что данный коллектор можно использовать при параллельных потоках.
        - UNORDERED - при выставлении данного значения в качестве характеристики коллектора означает,
                      что данный коллектор не несет на себе обязательств за сохранения порядка следования
                      элементов при добавлении этих значений во внутренний контейнер.
        - IDENTITY_FINISH - при выставлении данного значения в качестве характеристики коллектора означает,
                            что функция finisher является функцией Identity (ничего не выполняющей) и значит
                            может быть отменена.

Чтобы написать свой Collector, нужно реализовать данный интерфейс, реализовав перечисленные выше функции.
В библиотеке Java содержатся уже готовые коллекторы для наиболее часто выполняемых задач. Все они расположены
в классе Collectors, который содержит только статические функции. (далее в примерах опускается Collectors
полагая, что был совершен статический импорт соответствующих функций).

Самое простое, что можно сделать с потоком (со стримом) это преобразовать его в какую-нибудь коллекцию.
Это можно сделать с помощью одного из следующих функций:
 - toList()
 - toMap()
 - toSet()
 - toCollection()

**************************************************************************************************************
Особое внимание следует уделить функции toCollection(). Стрим (поток) сам пытается понять,
какая лучше реализация интерфейса коллекции подходит для функций toList, toMap или toSet.
Но если программист хочет чтобы использовался, например, TreeSet для преобразования в Set,
то нужно воспользоваться функцией toCollection следующим образом:
--------------------------------------------------------------------------------------------------------------
Set<Integer> set = list.stream().collect(toCollection(TreeSet::new));
--------------------------------------------------------------------------------------------------------------
С помощью коллекторов можно находить максимальное, минимальное и среднее значение из потока.
*** Для этого есть следующие функции:
 - maxBy(Comparator<? super T> comparator)
 - minBy(Comparator<? super T> comparator)
 - averagingInt(ToIntFunction<? super T> mapper)
 - averagingLong(ToLongFunction<? super T> mapper)
 - averagingDouble(ToDoubleFunction<? super T> mapper)

Отметим, что перед тем, как считать среднее значение все элементы преобразуются к примитивному типу
(указан в имени функции) с помощью функции mapper.

Также элементы потока можно группировать и соединять.
***Для этого есть следующие функции:
 - partitioningBy(Predicate<? super T> predicate) - данная функция разбивает набор элементов потока на
   два подмножества - те, которые удовлетворяют заданному предикату, и те, которые ему не удовлетворяют.
   Результатом будет объект типа Map. Ключами будут два значения - true и false. Для ключа true будут
   соответствовать все элементы, удовлетворяющие предикату, а для ключа false - не удовлетворяющие.
   Значения по ключу будут храниться в списке.

 - groupingBy(Function<? super T, ? extends K> classifier) - данная функция группирует элементы по какому-то
   признаку. Различие этой функции от partitioningBy в том, что полученных групп может быть сколько угодно
   много. Ключом группы будет, то что возвращает classifier, а значением по ключу будет список. Также заметим,
   что пустых групп быть не может.

 - joining(CharSequence delimiter) - данная функция соединяет значения потока в строку с заданным разделителем.

 - joining(CharSequence delimiter, CharSequence prefix, CharSequence suffix) - отличие этой функции от предыдущей
   в том, что к полученной строке в начале и в конце добавляется prefix и suffix соответственно.

Рассмотренные выше функции сами по себе носят мало практического характера. Вся суть этих функций в том,
что из них можно строить композиции вызовов, что позволяет строить простые и в то же время мощные выражения.

Например, пусть у нас стоит задача разбить список на группы и подсчитать сколько элементов получилось в группах.
Это можно сделать с помощью композиций коллекторов и коллектора counting:
--------------------------------------------------------------------------------------------------------------
Map<Boolean, Long> mn = list.stream()
        .collect(partitioningBy(x -> x > 6, counting()));
--------------------------------------------------------------------------------------------------------------

Кроме подсчета значений в группе можно также преобразовывать значения в группах. Это также можно сделать с
помощью композиций коллекторов.

Для этого есть коллектор mapping.

Например, пусть у нас есть задача написать функцию, которая принимает список, правило разбиения элементов
списка, а также функцию-маппер для изменения элементов в группе. Эта функция должна разбить элементы с
помощью первой функции, а потом применить маппер к каждому элементу каждой группы.
Такая функция может выглядеть следующим образом:
--------------------------------------------------------------------------------------------------------------
Map<Integer, List<Integer>> partition(List<Integer> list,
        Function<Integer, Integer> function, Function<Integer, Integer> mapper)
        {
        return list.stream().collect(groupingBy(function, mapping(mapper, toList())));
        }
--------------------------------------------------------------------------------------------------------------
Сначала будет происходить группировка элементов списка, потом будет применяться функция mapper к каждому
элементу каждой непустой группы. В конце полученные новые значения в группах будут преобразованы к списку.

(Уроки напоминалки Less_24_ch_12_Stream_Collect и Less_24_ch_16_Stream_MapToInt связанны, описания
в ReadMe.txt обоих уроков дополняют друг друга, как и примеры, где-то проще, где-то сложнее)