package Less_24_ch_6_Stream_ChainingMth;

import java.util.Arrays;

/*
Примеры работы цепочки методов в стрим структурах.
*/
public class Less_24_Stream_Training_Step1 {
    public static void main(String[] args) {
        int[] array_of_int = {3, 4, 12, 83, 41, 29, 34, 47, 7, 13, 47, 96};

        /*
        1. Отфильтруем наш массив в стриме так, чтобы остались только нечетные числа.
        2. Выбираем из отфильтрованных, только те, что делятся на 3-и без остатка.
        3. И найдем сумму оставшихся измененных чисел и вывести на экран.

            !!! В результате большой цепочки методов Stream, их условий или содержания массива
        (коллекции) может сложиться ситуация, когда на втором или третьем (n - ом) методе у нас
        получится, пустота на выходе!!!
            Т.е. если рассматривать наш пример, метод filter может отсеять все элементы
        стрима, если вдруг все элементы исходного массива четные, и дальнейшим методам просто
        не с чем будет работать.
            И в итоге мы не сможем получить единственную цифру, равную сумме всех оставшихся
        после фильтрации и всяческих преобразований элементов, и вывести ее на экран.
            И цепочка выкинет: Exception in thread "main" NoSuchElementException
        */

        Arrays.stream(array_of_int). // Формируем стрим из массива.
        filter(elem -> elem%2 == 1). // Пропускаем дальше по стриму только нечетные.
        map(af_elem -> { // Преобразуем одни элементы в другие согласно условию.
            if(af_elem%3 == 0) // Если делятся на 3-и без остатка, то
            {af_elem = af_elem/3;} // делим на 3-и, перезаписываем элемент и пропускаем дальше по стриму,
            return af_elem;}). // если не делится на 3-и без остатка просто пропускаем дальше по стриму.
        reduce((accum, af_map_elem)-> accum + af_map_elem). // Суммируем все элементы стрима.
        ifPresent(elem -> System.out.println(elem)); // Выводим на экран результат, если не пустота.

    }
}
