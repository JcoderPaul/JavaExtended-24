Ссылка на объект класса Optional может ссылаться на объект, а может указывать на null (пустоту).
К примеру, попытаемся извлечь из массива (коллекции) элемент которого там нет (а может и есть).
Т.е. применяем некий метод, который просто исполняет указанную команду без проверки возможно
ли ее исполнить или нет.

Возможно, искомый элемент в массиве есть (или userID в базе), а возможно и нет. Если такого
элемента нет, мы хапнем в стектрейс NullPointerException (или другое исключение, говорящее
о невозможности нормально продолжать работу программы).

Для решения подобных коллизий существует класс Optional и его методы.
Иначе пришлось бы писать всякого рода проверки.

Мы получаем ссылку, в которой может быть запрашиваемый объект — а может быть null.
Но с Optional надо как-то работать дальше, нам нужна сущность, которую он содержит
(или не содержит).

Cуществует всего три категории Optional:
 - Optional.of — возвращает Optional-объект.
 - Optional.ofNullable -возвращает Optional-объект,
   а если нет дженерик-объекта, возвращает пустой Optional-объект.
 - Optional.empty — возвращает пустой Optional-объект.

Существует два метода, позволяющие понять существует обёрнутый объект или нет — isPresent() и ifPresent():
 - *.ifPresent() - Метод позволяет выполнить какое-то действие, если объект не пустой.
Например: Optional.of(repository.findById(userId)).ifPresent(createLog());

 - *.isPresent() - Метод возвращает ответ, существует ли искомый объект или нет, в виде Boolean.
Например: Boolean present = repository.findById(userId).isPresent();

Для того чтобы получить объект, содержащийся по ссылке на Optional существует три прямых
метода дальнейшего получения объекта из семейства orElse(). Как следует из названия, эти
методы срабатывают в том случае, если объекта в полученном Optional не нашлось.
 - orElse() — возвращает объект по дефолту.
 - orElseGet() — вызывает указанный метод.
 - orElseThrow() — выбрасывает исключение.

*** Метод *.orElse() ***
Подходит для случаев, когда нам обязательно нужно получить объект, пусть даже и пустой.
Пример кода, в таком случае, может выглядеть так (при отсутствии userId возвращаем нового user-a):

User user = repository.findById(userId).orElse(new User());

Эта конструкция гарантированно вернёт нам объект класса User. Она очень выручает на начальных
этапах познания Optional, а также, во многих случаях, связанных с использованием Spring Data JPA
(там большинство классов семейства find возвращает именно Optional).

*** Метод *.orElseThrow() ***
Очень часто, и опять же, в случае с использованием Spring Data JPA, нам требуется явно заявить,
что такого объекта нет, например, когда речь идёт о сущности в репозитории. В таком случае,
мы можем получить объект или, если его нет, выбросить исключение.

Пример: User user = repository.findById(userId).orElseThrow(() -> new NoEntityException(userId));

Если сущность не обнаружена и объект null, будет выброшено исключение NoEntityException
(в данном случае, самописное). Например, на клиента уходит строчка:
«Пользователь {userID} не найден. Проверьте данные запроса».

*** Метод *.orElseGet() ***
Если объект не найден, Optional оставляет пространство для «Варианта Б», т.е. мы можем выполнить
другой метод, например:

User user = repository.findById(userId).orElseGet(() -> findInAnotherPlace(userId));

В данном примере, если объект не был найден, предлагается поискать в другом месте.

Этот метод, как и orElseThrow(), использует Supplier. Также, через этот метод можно, вызвать объект
по умолчанию, как и в *.orElse() например так:

User user = repository.findById(userId).orElseGet(() -> new User());

*** Методы преобразования объекта ***
Помимо методов получения объектов, существуют инструменты преобразования объекта, унаследованный от stream().
 - get() — возвращает объект, если он есть.
 - map() — преобразовывает объект в другой объект.
 - filter() — фильтрует содержащиеся объекты по предикату.
 - flatmap() — возвращает множество в виде стрима.

*** Метод *.get() ***
Метод get() возвращает объект, запакованный в Optional.

Например: User user = repository.findById(userId).get();

Будет получен объект User, запакованный в Optional. Такая конструкция крайне опасна,
поскольку минует проверку на null и лишает смысла само использование Optional, поскольку
мы можем получить желаемый объект, а можем и null.

Подобную конструкцию необходимо оборачивать в .isPresent().

*** Метод *.map() ***
Этот метод полностью повторяет аналогичный метод для stream(), но срабатывает только в том
случае, если по Optional ссылке есть not-null объект.

String name = repository.findById(userId).map(user -> user.getName()).orElseThrow(() -> new Exception());

В примере мы получили одно из полей класса User, упакованного в Optional.

*** Метод *.filter() ***
Данный метод также позаимствован из stream() и фильтрует элементы по условию.

List<User> users = repository.findAll().filter(user -> user.age >= 18).orElseThrow(() -> new Exception());

*** Метод *.flatMap() ***
Этот метод делает ровно то же, что и стримовский, с той лишь разницей, что он работает только
в том случае, если значение ссылки или итогов работы прочих методов не null.

Класс Optional, при умелом использовании, значительно сокращает возможности приложения рухнуть
с NullPoinerException (и другими видами исключений), делая его более понятным и компактным,
чем как если бы мы делали бесчисленные проверки на null.